import {
    dirname,
    fromFileUrl,
    join,
    toFileUrl,
} from "https://deno.land/std@0.151.0/path/mod.ts";
import { stringify as json5stringify } from "https://deno.land/x/json5@v1.0.0/mod.ts";
import { walk } from "https://deno.land/std@0.151.0/fs/mod.ts";
import { dirs } from "../dev.ts";

export type ManifestKeys = keyof typeof dirs;
export type ManifestItems = string[];
export type Manifest = { [K in ManifestKeys]: ManifestItems };

// deno-lint-ignore no-explicit-any
function enumKeys(enumObject: { [key: string]: any; }){
  const values = Object.values(enumObject);
  const keys = Object.keys(enumObject).filter(k => !values.some(v => String(v) === String(k) && typeof(v) !== typeof(k)));
  return keys;
}

export async function collect(rootDirectory: string): Promise<Manifest> {
  const manifest = {} as Manifest;
  const keys = enumKeys(dirs);
  // deno-lint-ignore prefer-const
  for (let dir of keys) {
    const manifestItems = await buildManifestItems(rootDirectory, dir);
    // deno-lint-ignore no-explicit-any
    (manifest as any)[dir] = manifestItems;
  }
  return manifest;
}

async function buildManifestItems(rootDirectory: string, folder: string): Promise<ManifestItems> {
  const manifestItems = [];
  try {
    const manifestItemsUrl = toFileUrl(join(rootDirectory, folder));
    // TODO(lucacasonato): remove the extranious Deno.readDir when
    // https://github.com/denoland/deno_std/issues/1310 is fixed.
    for await (const _ of Deno.readDir(folder)) {
      // do nothing
    }
    const manifestItemFolder = walk(folder, {
      includeDirs: false,
      includeFiles: true,
      exts: ["tsx", "jsx", "ts", "js"],
    });
    for await (const entry of manifestItemFolder) {
      if (entry.isFile) {
        const file = toFileUrl(join(rootDirectory, entry.path)).href.substring(
          manifestItemsUrl.href.length
        );
        manifestItems.push(file);
      }
    }
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      // Do nothing.
    } else {
      throw err;
    }
  }
  manifestItems.sort();
  return manifestItems;
}

export async function generate(directory: string, manifest: Manifest) {
  const manifestFormatted = {
    baseUrl: "import.meta.url"
  // deno-lint-ignore no-explicit-any
  } as any;

  Object.keys(manifest).forEach((k, index) => {
    manifestFormatted[k] = {};
    // deno-lint-ignore no-explicit-any
    ((manifest as any)[k] as string[]).forEach((file, i) => {
      manifestFormatted[k][`./${k}${file}`] = `$${index}_${i}`
    });
  });

  const output = `// DO NOT EDIT. This file is generated by fresh.
// This file SHOULD be checked into source version control.
// This file is automatically updated during development when running \`dev.ts\`.
${
  Object.entries(manifest).map(([k, m], index) =>
    (
      m.map((file, i) => `import * as $${index}_${i} from "./${k}${file}";`
    ).join("\n"))
  ).join("\n")
}

const manifest = ${ json5stringify(manifestFormatted, null, 2).split(": '").join(': ').split("',").join(',') };

export default manifest;
`;
  const proc = Deno.run({
    cmd: [Deno.execPath(), "fmt", "-"],
    stdin: "piped",
    stdout: "piped",
    stderr: "null",
  });
  const raw = new ReadableStream({
    start(controller) {
      controller.enqueue(new TextEncoder().encode(output));
      controller.close();
    },
  });
  await raw.pipeTo(proc.stdin.writable);
  const out = await proc.output();
  await proc.status();
  proc.close();

  const manifestStr = new TextDecoder().decode(out);
  const manifestPath = join(directory, "./fresh.gen.ts");

  await Deno.writeTextFile(manifestPath, manifestStr);
  console.log(
    `%cThe manifest has been generated.`,
    "color: blue; font-weight: bold",
  );
}

export async function dev(base: string, entrypoint: string) {
  entrypoint = new URL(entrypoint, base).href;

  const dir = dirname(fromFileUrl(base));

  let currentManifest: Manifest;
  const prevManifest = Deno.env.get("FRSH_DEV_PREVIOUS_MANIFEST");
  if (prevManifest) {
    currentManifest = JSON.parse(prevManifest);
  } else {
    currentManifest = {} as Manifest;
    enumKeys(dirs).forEach(k => {
      // deno-lint-ignore no-explicit-any
      (currentManifest as any)[k] = [];
    })
  }
  const newManifest = await collect(dir);
  Deno.env.set("FRSH_DEV_PREVIOUS_MANIFEST", JSON.stringify(newManifest));

  const manifestChanged =
    !arraysEqual(newManifest.routes, currentManifest.routes) ||
    !arraysEqual(newManifest.islands, currentManifest.islands);

  if (manifestChanged) await generate(dir, newManifest);

  await import(entrypoint);
}

function arraysEqual<T>(a: T[], b: T[]): boolean {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
